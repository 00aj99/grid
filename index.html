<html>
<head>
  <style>
* {
  margin: 0;
  padding: 0;
  font-family: sans-serif;
}
.grid {
  margin: 20px;
  position: relative;
  list-style: none;
  /* TODO: expand grid with items */
}
.grid li {
  position: absolute;
  background: rgba(200, 200, 200, 0.9);
  box-shadow: inset 0 0 0 2px #fff;
  font-size: 40px;
  font-weight: bold;
  line-height: 80px;
  text-align: center;
  cursor: pointer;
  -webkit-transition: top 0.2s, left 0.2s;
}
.grid li.ui-draggable-dragging {
  -webkit-transition: none;
}
  </style>
  <script src="http://ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js"></script>
  <script src="http://ajax.googleapis.com/ajax/libs/jqueryui/1.10.3/jquery-ui.min.js"></script>
  <script src="lib/underscore-min.js"></script>
  <script src="lib/gridList.js"></script>
  <script>
var GRID_ITEM_TYPES = {
  widget1x1: [1, 1, false],
  widget2x1: [2, 1, false],
  widget3x1: [3, 1, false],
  timeline1x: [1, 4, false],
  timeline2x: [2, 4, false],
  timeline3x: [3, 4, false]
};

var itemsGrid1 = [
  GRID_ITEM_TYPES.widget1x1,
  GRID_ITEM_TYPES.widget1x1,
  GRID_ITEM_TYPES.widget1x1,
  GRID_ITEM_TYPES.widget1x1,
  GRID_ITEM_TYPES.widget2x1,
  GRID_ITEM_TYPES.widget3x1,
  GRID_ITEM_TYPES.timeline1x,
  GRID_ITEM_TYPES.widget1x1,
  GRID_ITEM_TYPES.widget1x1,
  GRID_ITEM_TYPES.widget2x1,
  GRID_ITEM_TYPES.widget1x1,
  GRID_ITEM_TYPES.widget1x1,
  GRID_ITEM_TYPES.timeline1x,
  GRID_ITEM_TYPES.widget1x1
];

var getFormattedItems = function(items) {
  var _items = [], i, item;
  for (i = 0; i < items.length; i++) {
    item = items[i];
    _items.push({
      cols: item[0],
      rows: item[1]
    })
  }
  return _items;
}

var buildGridElements = function($gridContainer, items) {
  var item, i;
  for (i = 0; i < items.length; i++) {
    item = items[i];
    $item = $('<li>' + (i + 1) + '</li>');
    $item.css({
      width: item.cols * 80,
      height: item.rows * 80
    })
    $gridContainer.append($item);
    // Add reference to corresponding DOM element to each item and viceversa
    item.$element = $item
    $item.data('_gridItem', item);
  }
};

var applyItemPositions = function(items) {
  // XXX very hackish implementation of Group separators
  $('.grid-separator').remove()
  var currGroup = 0;
  var item, i;
  for (i = 0; i < items.length; i++) {
    item = items[i];
    // Don't apply position to dragged elements
    if (item.drag) {
      continue;
    }
    item.$element.css({
      left: item.position.col * 80,
      top: item.position.row * 80
    })
    if (item.position.col % 3 > currGroup) {
      currGroup++;
      var $separator = $('<div class="grid-separator"></div>');
      $separator.css({
        position: 'absolute',
        width: 2,
        height: 320,
        left: 20 + 240 * currGroup - 1,
        top: 20,
        background: 'red'
      });
      $('body').append($separator);
    }
  }
};

var updateItemIndexes = function(items) {
  var item, i;
  for (var i = 0; i < items.length; i++) {
    item = items[i];
    item.$element.html(i + 1);
  }
};

var getItemByElement = function(element) {
  return $(element).data('_gridItem');
};

var setDragMovementToItem = function(item, ui) {
  if (!item.previousPosition) {
    item.drag = {
      x: ui.position.left - ui.originalPosition.left,
      y: ui.position.top - ui.originalPosition.top
    };
  } else {
    item.drag = {
      x: ui.position.left - item.previousPosition.left,
      y: ui.position.top - item.previousPosition.top
    };
  }
  item.previousPosition = {
    left: ui.position.left,
    top: ui.position.top
  };
}

var positionItemToGrid = function(item) {
  var position = item.$element.position();
  item.position.col = Math.round(position.left / 80);
  item.position.row = Math.round(position.top / 80);
};

var areCollidingItems = function(item1, item2) {
  return !(item2.position.col >= item1.position.col + item1.cols ||
           item2.position.col + item2.cols <= item1.position.col ||
           item2.position.row >= item1.position.row + item1.rows ||
           item2.position.row + item2.rows <= item1.position.row);
};

$(function() {
  var items = getFormattedItems(itemsGrid1),
      item, i;

  buildGridElements($('#grid1'), items);

  myGrid = new GridList(items, {
    colsPerGroup: 3,
    rows: 4,
    sortItemsByPosition: function(items) {
      // README: Regular sorting doesn't work for this scenario, as it doesn't look
      // at all neighbours due to optimization reasons. Since we're sorting objects
      // from their 2d position into the 1d index (using our Groups positioning
      // algorithm), the 4th next element might overlap with the one we're dragging,
      // while the 3rd might not. Hence the 4th will be shifted before the dragged
      // one, while the 3rd will remain after. For this we need to iterate through
      // all the list item combinations.
      var collidingItems = [],
          i, j,
          dragItem, collidingItem,
          movementDirection;
      for (i = 0; i < items.length; i++) {
        dragItem = items[i];
        if (!dragItem.drag) {
          continue;
        }
        for (j = 0; j < items.length; j++) {
          if (i == j) {
            continue;
          }
          collidingItem = items[j];
          if (areCollidingItems(dragItem, collidingItem)) {
            collidingItems.push(j);
          }
        }
        // There's only one drag at a time
        break;
      }
      if (!collidingItems.length) {
        return;
      }
      // Detect on which axis does the dragging movement stand out
      if (Math.abs(dragItem.drag.x) > Math.abs(dragItem.drag.y)) {
        movementDirection = dragItem.drag.x;
      } else {
        movementDirection = dragItem.drag.y;
      }
      // If we're dragging to the right/bottom, move all colliding items to the
      // left, and vice-versa
      while (collidingItems.length) {
        if (movementDirection > 0) {
          collidingItem = items.splice(collidingItems.shift(), 1)[0];
          items.splice(this._getIndexOfItem(dragItem), 0, collidingItem);
        } else {
          collidingItem = items.splice(collidingItems.pop(), 1)[0];
          items.splice(this._getIndexOfItem(dragItem) + 1, 0, collidingItem);
        }
      }
    }
  });

  myGrid.generatePositionsFromIndex();
  applyItemPositions(items);

  $('#grid1 > li').draggable({
    zIndex: 2,
    drag: function(event, ui) {
      var item = getItemByElement(ui.helper);
      positionItemToGrid(item);
      setDragMovementToItem(item, ui)

      myGrid.generateIndexesFromPosition();
      updateItemIndexes(items);

      myGrid.generatePositionsFromIndex();
      applyItemPositions(items);
    },
    stop: function(event, ui) {
      var item = getItemByElement(ui.helper);
      item.drag = null;

      applyItemPositions(items);
    }
  });
});
  </script>
</head>
<body>
  <ul id="grid1" class="grid"></ul>
</body>
